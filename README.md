LABORATORY WORK 2


1. :warning: **В чому різниця між setTimeout та setInterval?**


- :white_check_mark: Основна різниця між ними полягає в тому, що `setTimeout` виконує код лише один раз з певною затримкою, тоді як `setInterval` виконує код повторно з певним інтервалом часу між кожним виконанням.
- :white_check_mark: Використання `setTimeout` та `setInterval` може відрізнятися у випадку, якщо код виконується довго часу. Якщо код виконується більше, ніж інтервал часу, встановлений для `setInterval`, то наступне виконання може початися до завершення попереднього виконання, що може призвести до накопичення відставань в часі. У таких випадках краще використовувати setTimeout для запуску наступного виконання коду лише після завершення попереднього виконання.

</br>

2. :warning: **Що таке блокуючий код?**

- :white_check_mark: При виконанні блокуючого коду, виконання JavaScript-коду зупиняється до того моменту, поки блокуючий код не буде повністю виконаний. Це може призвести до затримок в відповіді на події користувача та погіршення загальної продуктивності.

</br>

3. :warning: Які переваги асинхроного  читання з диску перед синхронним?

- :white_check_mark: Неблокуючий режим: Асинхронне читання дозволяє виконувати інші операції, поки дані читаються з диску. Це означає, що виконання коду не буде зупинятися, щоб дочекатися завершення читання з диску, що дозволяє програмі продовжувати роботу без затримок.
- :white_check_mark: Краща масштабовність: Асинхронне програмування дозволяє програмі виконувати більше завдань одночасно, що забезпечує кращу масштабовність. Це особливо важливо при роботі з великими об'ємами даних та високими навантаженнями на сервер.
- :white_check_mark: Покращена реактивність: Асинхронні операції можна комбінувати з обробкою подій (event-driven) для створення реактивних інтерфейсів користувача. Це дозволяє програмі реагувати на події користувача в режимі реального часу, не блокуючи виконання коду.
- :white_check_mark: Краща продуктивність: Синхронне читання з диску заблоковує виконання коду до того моменту, поки дані не будуть повністю зчитані з диску. Це може призвести до затримок у відповіді та зниження продуктивності, особливо при обробці великих об'ємів даних. Асинхронне читання з диску дозволяє уникнути цих затримок, що покращує продуктивність програми.

</br>

4. :warning: **Опишіть різницю між Callbacks API, Promise API та async/await.**

- :white_check_mark:  Почнемо з Callbacks API. З самого початку треба зрозуміти, що колбеки (функції оберненого виклику) не являються асинхронними (в чому і полягає їхня найголовніша відмінність від промісів та конструкції асінк / евейт). Callbacks API - це звичайні функції, які передаються як параметри в інші функції (які зачасту мають якийсь асинхронний код, наприклад, setTimeout), щоб вони були викликані не як синхронні (зразу зі стеку), а тільки після того, як виконається асинхронний код з черги. Приклад:
```
const fun = (callback) => {
    setTimeout(() => {
        console.log(1);
        callback();
    }, 0);
}

const callbackFun = () => {
    console.log(2);
}

fun(callbackFun);
```
Результатом виконання коду буде вивід чисел 1 та 2.

- :white_check_mark:  Promise API. З'явились з появою ES6. Promise - це об'єкт, який має два параметра - resolve, reject - та три стани - pending, fulfilled, rejected, де pending - вихідний стан проміса, fulfilled - успішно виконаний проміс, rejected - відхилений проміс. Коли ми ініціалізуємо проміс (new Promise), ми маємо передати resolve та reject як параметри. Всередині проміса ми можемо писати вже повноцінно асинхронний код, який буде при виконанні колбека resolve повертати успішно отримані дані, а при виконанні reject - повідомляти про помилку. Відмінність проміса в тому, що він частково блокує код. Той код, який має виконуватись після проміса, поміщається в методи then, catch або finally. then викликається, коли виконується resolve, catch - коли reject, finally - після завершення проміса. У промісів є метод Promise.all(), який може виконати якусь дію тільки після того, як обробляться всі проміси, що передаються параметром як масив.

- :white_check_mark: async / await. З'явились з появою ES7. Дана конструкція дозволяє обробляти асинхронний код так, ніби він синхронний. Під капотом використовуються вже вивчені проміси. async - об'являє асинхронну функцію, await - дозволяє працювати з даними, що повернулись після виконання асинхронщини. Помилки можна обробити за допомогою конструкції try-catch.

</br>

5. :warning: **Як обробляються помилки при використанні Promise API?**

- :white_check_mark: Promise - це об'єкт, який має два параметри - resolve та reject, та три стани - pending, fulfilled та rejected. Обробку помилок можна здійснювати всередині промісів за допомогою конструкції try-catch, власних перевірок або колбеків, які будуть повертатись, якщо запит на ресурс завершиться з помилкою. Як тільки помилка виникне всередині проміса, необхідно викликати метод reject та передати параметром повідомлення про помилку, об'єкт, статус-код тощо. Обробка помилок здійснюється за допомогою методу catch проміса.

</br>

6. :warning: **Як створити директорію через модуль fs? За що відповідає параметр mode?**
- :white_check_mark: Для створення директорії через модуль fs в JavaScript можна використовувати метод mkdir (або mkdirSync для синхронної операції). Синтаксис методу mkdir:
`fs.mkdir(path[, mode], callback)`
Де path - шлях до директорії, mode - необов'язковий параметр, що відповідає за права доступу до директорії (якщо не вказувати цей параметр, за замовчуванням встановлюються права 0o777), callback - функція, яка буде викликана після того, як директорія буде створена або виникне помилка.
- :white_check_mark: Параметр mode відповідає за права доступу до створеної директорії. Він може приймати значення від 0 до 0o777 (восьмеричне число), де кожна цифра представляє права доступу для відповідної групи користувачів (власник, група, інші). Наприклад, 0o755 надає власнику повний доступ, а групі та іншим - тільки читання та виконання. Якщо параметр mode не вказувати, то за замовчуванням встановлюються права 0o777, тобто всі групи користувачів мають повний доступ до директорії.


